<pre>
  BIP: ?
  Title: 2017 Hardfork
  Author: Luke Dashjr <luke_bip-mmhf@dashjr.org>
  Status: Draft
  Type: Standards Track
  Created: 2015-02-12
</pre>

==Abstract==

Expand block size and mining nonce space, as well as add native merge-mining support.

==Specification==

=== Block header fields ===

Each block includes a number of header fields:

* A total of up to 600 bits of nonce space:
** 32-bit class 1 nonce which can be changed immediately before the final stage of the DMMS (PoW) calculation
** 24-bit class 2 nonce
** Variable-length (32-bit to 544-bit) class 3 nonce
* Previous block's hash
* Timestamp, truncated to 32-bit
* Height
* 8-bit merge-mining-hardfork deployment bitfield
* 16-bit hardfork deployment bitfield
* 32-bit softfork deployment bitfield (as in BIP 9)

In addition, the block includes a set of transactions.

The transactions must update the UTXO state from the previous block.
If they attempt to consume a serial that does not exist in the UTXO state (whether from the previous block, or added during processing of this block), the block is invalid.

Witnesses for inputs consuming a valid UTXO must be checked against the pubkey script for that UTXO.
If such a check fails for any input, the block is invalid.

The total cost of transactions in a block must not exceed FIXME nor the total sigop count exceed FIXME, or the block is invalid.
FIXME: SigOps within new blocks are to be counted only in witness scripts and the UTXO pubkey scripts they are checked against (no longer pubkey scripts of new UTXOs) using the counting rules from BIP 141.

=== Merkle tree algorithm ===

For each object, compute a hash which represents it in the merkle tree (eg, txid or hash of the full transaction).
Arrange these hashes into a vector.

So long as the vector is more than one element, compress each set of two elements by replacing them with a SHA256d hash of:

* 216 bits: leading 216 bits of the first element
* 216 bits: leading 216 bits of the second element
* 1 bit: element type
* 1 bit: plurality (usually 1; see below)
* 1 bit: merkle root (always 0 here)
* 5 bits: always zero

When the vector has an odd number of elements, the final element should be compressed with a SHA256d hash of:

* 216 bits: leading 216 bits of the only remaining element
* 216 bits: all zero
* 1 bit: element type
* 1 bit: plurality (0 in this case)
* 1 bit: merkle root (always 0 here)
* 5 bits: always zero

For the first iteration of the compression loop (that is, when the elements being compressed are the object hashes themselves), the element type should be 1; for subsequent iterations, it must always be 0.

Finally, to create the final merkle tree root, one last SHA256d hash is performed of:

* 152 bits: all zero
* 64 bits: total number of elements in vector, encoded as big endian
* 216 bits: complete remaining element
* 1 bit: element type (iff the vector was 1 item long, this will be 1)
* 1 bit: plurality (always 0 here)
* 1 bit: merkle root (always 1 here)
* 5 bits: always zero

By committing to the total number of elements in the merkle root, it avoids unbalanced merkle trees from being used to attack systems checking only part of the tree.

=== Dynamic membership multiparty signature DMMS) algorithm ===

Hash TMR ("Transaction Merkle Root") is produced by performing the merkle tree algorithm with the ids of all transactions to be included in the block.

Hash WMR ("Witness Merkle Root") is produced by performing the merkle tree algorithm with the full hash (including witness data) of all transactions to be included in the block.

Hash H-C ("Header C") is produced by performing SHA256d over the following data (FIXME: endian):

TODO: Order fields by what might make sense to midstate-compress out?

* 2 bytes: hardfork deployment bitfield
* 4 bytes: softfork deployment bitfield
* 8 bytes: transaction data canonical size (in bytes)
* 8 bytes: transaction cost total
* 8 bytes: transaction sigop total
* 4 bytes: transaction count
* 32 bytes: Hash TMR
* 32 bytes: Hash WMR

Hash CMR ("Commitment Merkle Root") is produced by performing the merkle tree algorithm with ... FIXME

Hash H-B ("Header B") is produced by performing SHA256d over the following data:

* 41 bytes: constant data:

    77 77 77 77  01 00 00 00  00 00 00 00  00 00 00 00
    00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
    00 00 00 00  00 ff ff ff  ff

* 1 byte: (length of following 5-103 bytes of data) minus 3
* 5-103 bytes:
* * serialised height (see BIP 34)
* * Hash CMR
* * Class 3 nonce
* 1 byte: length of preceding data (for midstate compression)
* 14 bytes: constant data:

    01 00 00 00  00 00 00 00  00 00 00 00 00 00

FIXME: Do we want to allow 0-value outputs? Necessary for 21inc compat; makes future OP_RETURN additions possible (but not an ideal location for added data)

Hash H-A ("Header A") is produced by performing SHA256d over the following data:

* 3 bytes: Class 2 nonce
* 1 byte: constant 0x60
* 32 bytes: Previous block's hash
* 32 bytes: Hash H-B
* 4 bytes: Timestamp
* 4 bytes: Class 1 nonce

Hash H-A is then to be interpreted as a little-endian (FIXME: check) number, and compared to the current block target.
If the hash is less than or equal to the target, the DMMS signature is valid.

=== Hardfork deployment bitfields ===

The hardfork deployment bitfields function as in BIP 9, however due to the nature of hardforks:

* Nodes MUST defer the "starttime" until the node has explicitly indicated consent of the entire network to the hardfork.
* Mining nodes specifically MUST defer the "starttime" until they are confident the entire network has consented to the hardfork AND indicated network support in their node.
* If an unrecognised hard fork bit reaches activation conditions on the longest chain, nodes must stop at the last block under the known rules until the node operator chooses to accept or reject the hardfork.
* If an unconsented/rejected hard fork bit reaches activation, the node should switch to the alternative proof-of-work algorithm to move forward from the forking point.
* A hardfork cannot be accepted by the node so long as it does not implement/recognise it. Until the software is upgraded, it can only remain in the "unrecognised" or "unconsented/rejected" state.
* FIXME: If greater than X% of transacted bitcoins over the signalling period indicate rejection of the hardfork, it must not activate.
* FIXME: how to deal with the original chain putting more work on a non-forking chain, after PoW has switched.

==Motivation==

Bitcoin mining needs to modify hashed data in order to find valid blocks.
32 bits of arbitrary data, the nonce, is available directly in the block header.
When this space is exhausted, miners are forced to modify the transaction data, traditionally the generation transaction's dummy scriptSig (the coinbase) to influence the merkle root in the block header.
However, this process is complicated, and not suitable for outsourcing to hardware, which is rapidly reaching hashrates that cannot be kept up with by computers.
By expanding the nonce space that can be searched in hardware, this problem is fixed.

TODO: Block cost limit increase (or another BIP?)

TODO: Merge mining

==Rationale==

One solution to the nonce size limit is to expand the nonce space available in the block header, either by allowing it to be variably longer than its current fixed size of 80 bytes, or by repurposing unused sections as additional nonce.
To expand the block size, it is sufficient to merely tolerate more transactions.

However, these methods of hardforking would leave old nodes not only broken, but susceptible to a security compromise as they will reject such new blocks, yet accept as valid a shorter chain satisfying the old rules.
This is addressed by implementing this hardfork using hashes that old nodes will recognise as valid empty blocks.

==Backward Compatibility==

This hardfork will permanently disable all nodes, both full and light, which do not explicitly add support for it.
However, their security will not be compromised due to the implementation (TODO: elaborate here).
To migrate, all nodes must choose to upgrade, and miners must express supermajority support.

If miners attempt to enact this hardfork against user consent, it is trivial to override with a minimal hardfork.

==Reference Implementation==

TODO
